# C++ Primer Note

## Chapter01 预备知识
### 1. 本章目标
- C++和C有什么区别和联系
- C++有什么特性
- 链接是什么
- 如何在命令行里执行一个C++程序：要求依赖其他文件，接收命令行参数
- C++文件的基本结构

### 2. C++ VS C
C语言：
1. 强调**算法**：面向过程，自顶向下，将大型程序分解成小型、便于管理的任务；
2. 融合低级语言的效率（*效率是如何体现的?C提供了低级硬件访问?*）和高级语言的通用性、可移植性；

C++语言：
1. 强调**数据**：面向对象，大型项目使用C++构建更容易被管理和理解(数据和对数据的操作的组合)
2. C++是C的超集，任何有效的C程序都是有效的C++程序；C++可以使用已有的C软件库

### 3. 链接
作用：将目标文件与该文件依赖的库的目标代码组合起来，生成可执行文件；

问题：如何组合的呢？

### 4. gcc VS g++
参考链接：[知乎文章:g++ vs gcc](https://www.zhihu.com/question/20940822)， [stackoverflow文章](https://stackoverflow.com/questions/172587/what-is-the-difference-between-g-and-gcc?r=SearchResults)

GCC: GUN Compiler Collection

gcc: GUN C Compiler,gcc不能自动和使用的C++库链接

g++: GUN C++ Compiler, g++ == gcc -xc++ -lstdc++ -shared-libgcc

### 5. 程序结构
```c++
#include <iostream>

int main()
{
    using namespace std;
    cout << "Hello world cpp";
    cout << endl;
    return 0;
}

```
#### include
预处理器：在代码被编译之前，替换或添加文本；#include编译指令导致iostream文件的内容随源代码文件的内容一起被发送给编译器。实际上，iostream文件的内容将取代程序中的代码行#include\<iostream\>。原始文件没有被修改，*而是将源代码文件和iostream组合成一个复合文件*，编译的下一阶段将使用该文件。
#### 名称空间
作用：厂商将产品封装在一个叫做名称空间的单元中，这样可以用名称空间的名称来指出想使用哪个厂商的产品。
#### cout输出
cout：一个预定义的对象，*注意是个对象不是函数*，cout对象包含一个插入操作符号(<<)，可以理解为调用了cout对象的方法<<，该方法在屏幕上显示输入的字符串。

流：随着时间的推移，字符是顺序生成和消耗的。

### 6. 函数
函数原型：返回值类型 + 函数名 + 参数列表 + 分号；原型只描述函数接口；应在首次使用函数之前提供其原型；

函数定义：包含了函数代码；在使用函数前提供函数原型，但是函数的实现可以写在使用函数的地方的后边。

## Chapter02 变量和基本类型
### 1.目标
- c++有哪些基本类型，每种类型的长度是多少？
- c++是否区分有符号和无符号？
- c++的字符支持那些操作？拼接、字符长度、子串等操作如何完成？string的底层实现是什么？算术类型和string如何转换？整型和char类型如何转换？
- c++的const能修饰哪些元素？
- c++

### 2. 基本类型
#### 2.1 字符类型
| type          | description                                             | min length |
| :------------ | :------------------------------------------------------ | ---------: |
| char          | 在不同的机器上，可以是signed char,也可以是unsigned char      |       8bit |
| unsigned char | 范围0～255                                               |       8bit |
| signed char   | 范围-128～127                                            |       8bit |
| wchar_t       | 宽字符                                                   |      16bit |
| char16_t      | Unicode字符                                              |      16bit |
| char32_t      | Unicode字符                                              |      32bit |

##### utf8 vs utf16 vs utf32
[stackoverflow: utf8-utf16-utf32](https://stackoverflow.com/questions/496321/utf-8-utf-16-and-utf-32)
- 什么情况下使用wchar_t和char16_t这种类型呢？
- Unicode：是一种字符集，每一个字符(包括亚洲字符、英文字符等)对应Unicode字符集中的一条记录；
- utf8 utf16 utf32:这三种对应的是三种将字符转换为字节码的方式，不管用什么方式转换后的二进制对应的十进制都是同一个值；

#### 2.2 类型转换
无符号>有符号：有符合和无符号在一起时会自动被转换为无符号，负值在转换为有符号数时=负数+无符号数的模；

**未定义**：当我们给带符号类型一个超出它表示范围的值时，结果是未定义的，结果可能是继续工作、崩溃或者生成垃圾数据等；

### 3. 变量
变量：每个变量都有其数据类型，数据类型决定着变量**所占内存空间的大小**和**布局方式**、该空间能存储的**值的范围**，以及变量**能参与的运算**；

#### 3.2 变量初始化
列表初始化：
- 无论是复杂类型还是简单类型，都可以用列表初始化；
- 如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错，但是普通初始化就不会报错（所以初始化时尽可能使用列表初始化更安全）
  
默认初始化：
- 如果定义变量时没有指定初始值，则变量被默认初始化；
- 内置类型的默认初始值由位置决定，函数体内部的内置类型变量将不被初始化，所以发生了错误很难定位，所以最好初始化每一个内置类型的变量；

#### 3.3 变量声明与定义
声明：规定了变量的类型和名字，由一个数据类型和紧随其后的变量名列表组成；

定义：规定了变量的类型和名字，还申请存储空间，也可能会为变量赋一个初始值；任何包含了显示初始化的声明即为定义；以下示例几种定义方式：
- int j；
- extern double pi = 3.1416
- extern int j；（这是声明不是定义）

说明：
- 这里可以和Java对比着来理解，Java中任何一个变量只能定义一次，这点和C++是一致的；但是Java其实是不区分声明和定义的，而C++是区别的，所以C++可以*有多次声明，但是只能又一次定义*；Java使用其他文件（也就是其他类，Java中没有全局变量一说）的变量，只需要import那个变量所在的包；但是C++中，如果要使用其他文件中的变量，需要包含头文件、extern变量，对外部变量做声明但是不能定义；

#### 总结
- 初始化每一个内置类型的变量；
- 声明可以有多次，定义只能有一次；只要在声明的时候赋了值就是定义；（赋值和定义不同，不是所有赋值都是定义，但是定义一定赋了值）

### 4. 复合类型
#### 4.1 指针
定义指针类型：类型 + *d，d是变量名；**指针的类型要和它指向的对象严格匹配**

空指针nullptr：C++11中新增的特殊类型的字面值，它可以被转换成任意其他的指针类型；【int *p1 = nullptr】等价于【int *p1 = 0】

指针初始化：在块作用域内如果指针没有被初始化，将指向一个不确定的值，往往会引发错误；所以，建议**初始化使用指针**；

指针VS引用：引用不是对象，但是指针是一个对象；所以一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问他最初绑定的那个对象；但是指针可以随时复制，随时指向一个新的对象（*引用到底有什么用呢？*）

指针比较：如果两个指针存放的地址相等（都为空、都指向同一个对象、或者都*指向了同一个对象的下一个地址？？？？*），则他们相等，比较返回true；

void\*指针：可以存放任意对象的值，因为无法判断void指向对象的类型，所以无法直接操作void\*指针所指的对象；

#### 4.2 const

const和指针：
- 指向常量的指针：指针可以指向其他对象，但是无法通过指针修改对象的值，不论这个对象是不是常量；指向一个常量的指针必须使用指向常量的指针；
  - const int i = 3; const int *p = \&i(合法); int *p1 = \&i(不合法);
- 常量指针：指针不可以指向其他对象，但是可以通过指针修改对象的值（如果指向的对象不是一个常量的话）；
  - const int i = 3; int *const p = \&i;

constexpr和常量表达式
- 定义：常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式；
- 一般来说，如果你认定一个变量是常量表达式，那就把它声明成constexpr类型；
- 常量表达式的值需要在编译时就得到计算，因此constexpr修饰的类型一般比较简单，值也显而易见，算术类型、引用、指针都属于字面值类型，但是自定义类、string类则不属于；
- 在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，声明此指针是一个常量，不能指向其他对象，但是与指针所指的值无关，指针所指的值可以是常量也可以是非常量；

#### 4.3 类型别名
typedef double wages;
using doubleAlias = double;

#### 4.4 auto
const int ci = 1;
constexpr int *np = \&ci; 定义了一个常量指针，这个指针是int类型；——顶层const
auto d = ci; d是一个整型，但不是常量整形；
auto e = \&ci; 定义了一个指向常量的指针；——底层const

#### 4.5 decltype
- decltype返回括号里变量或者表达式结果的类型；
- 特别说明：
  - decltype(r)：如果r是引用类型，但是想让结果类型是r所指向的类型，可以把r作为表达式的一部分，decltype(r+0)返回的类型就是r所指向的类型；
  - decltype(*p)：如果p是指针（假设是int\*指针），这个解引用操作返回的是引用类型int&而非int；
  - decltype((i))：i是一个int类型，这里返回的是int&而不是int；（这种奇妙且易错的设定说明场景下会使用呢：））

### 总结
- C++本身的类型非常繁多：
  - 数值类型：short、int、long、long long、double、float，每一种整形又区分有符号和无符号；
  - 字符类型：char、wchar_t、char16_t、char32_t，char本身也区分有符号和无符号，char16_t最少占用2个字节，char32_t占用4个字节，char最少占用1个字节；
  - 复合类型：引用、指针
- 类型的声明、定义与初始化
  - 块外未初始化的变量会赋一个初始值，但是块内未初始化的变量会赋一个未定义值，未定义值可能引起无法预料的错误；
  - 定义 = 声明 + 初始化（赋值）；
  - const、constexpr
  - typedef、auto、decltype
- 理论上，采用复杂性是为了达成某种目的与优化而采取的手段，后续需要研究，C++这些复杂的类型有什么作用？引用、auto、typedef的使用场景是什么？有了const还有constexpr真的有意义吗？引用、auto、typedef、constexpr在开源代码或者真正的项目开发里使用多吗？